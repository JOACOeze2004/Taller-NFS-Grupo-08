#include "track_serializer.h"
#include "yaml_parser.h"
#include <QFile>
#include <QTextStream>
#include <QDateTime>
#include <QDebug>

bool TrackSerializer::saveToFile(const RaceTrackData& data, const QString& filePath) {
    QString yaml = serializeToYaml(data);

    QFile file(filePath);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << "No se pudo abrir el archivo para escribir:" << filePath;
        return false;
    }

    QTextStream out(&file);
    out << yaml;
    file.close();

    qDebug() << "Recorrido guardado:" << filePath;
    return true;
}

bool TrackSerializer::loadFromFile(const QString& filePath, RaceTrackData& data) {
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        qWarning() << "No se pudo abrir el archivo para leer:" << filePath;
        return false;
    }

    QString yaml = file.readAll();
    file.close();

    return deserializeFromYaml(yaml, data);
}

QString TrackSerializer::serializeToYaml(const RaceTrackData& data) {
    QString yaml;
    QTextStream stream(&yaml);

    stream << "# Need for Speed - Race Track Configuration\n";
    stream << "# Generated by Track Editor\n\n";

    stream << "version: \"1.0\"\n";
    stream << "cityId: \"" << data.cityId << "\"\n";
    stream << "trackName: \"" << (data.trackName.isEmpty() ? "Sin nombre" : data.trackName) << "\"\n";
    stream << "author: \"" << (data.author.isEmpty() ? "Desconocido" : data.author) << "\"\n";
    stream << "createdDate: \"" << (data.createdDate.isEmpty()
        ? QDateTime::currentDateTime().toString(Qt::ISODate)
        : data.createdDate) << "\"\n\n";

    stream << "checkpoints:\n";
    if (data.checkpoints.empty()) {
        stream << "  []\n";
    } else {
        for (const auto& cp : data.checkpoints) {
            stream << "  - x: " << cp.position.x() << "\n";
            stream << "    y: " << cp.position.y() << "\n";
            stream << "    order: " << cp.order << "\n";
        }
    }
    stream << "\n";

    stream << "hints:\n";
    if (data.hints.empty()) {
        stream << "  []\n";
    } else {
        for (const auto& hint : data.hints) {
            stream << "  - x: " << hint.position.x() << "\n";
            stream << "    y: " << hint.position.y() << "\n";
            stream << "    rotation: " << hint.rotation << "\n";
        }
    }

    return yaml;
}

bool TrackSerializer::deserializeFromYaml(const QString& yaml, RaceTrackData& data) {
    data.checkpoints.clear();
    data.hints.clear();

    QStringList lines = yaml.split('\n');
    int currentLine = 0;

    QMap<QString, QString> metadata = YamlParser::parseMetadata(lines, currentLine);

    if (metadata["version"] != "1.0") {
        qWarning() << "VersiÃ³n no soportada:" << metadata["version"];
        return false;
    }

    data.cityId = metadata["cityId"];
    data.trackName = metadata["trackName"];
    data.author = metadata["author"];
    data.createdDate = metadata["createdDate"];

    while (currentLine < lines.size() && lines[currentLine].trimmed() != "checkpoints:") {
        currentLine++;
    }
    if (currentLine < lines.size()) {
        currentLine++;
        QList<YamlParser::YamlItem> checkpointItems = YamlParser::parseList(lines, currentLine);

        for (const auto& item : checkpointItems) {
            CheckpointData cp;
            cp.position.setX(item.properties.value("x", 0));
            cp.position.setY(item.properties.value("y", 0));
            cp.order = static_cast<int>(item.properties.value("order", 0));
            data.checkpoints.push_back(cp);
        }
    }

    while (currentLine < lines.size() && lines[currentLine].trimmed() != "hints:") {
        currentLine++;
    }
    if (currentLine < lines.size()) {
        currentLine++;
        QList<YamlParser::YamlItem> hintItems = YamlParser::parseList(lines, currentLine);

        for (const auto& item : hintItems) {
            HintData hint;
            hint.position.setX(item.properties.value("x", 0));
            hint.position.setY(item.properties.value("y", 0));
            hint.rotation = item.properties.value("rotation", 0);
            data.hints.push_back(hint);
        }
    }

    qDebug() << "Recorrido cargado:" << data.trackName
             << "(" << data.checkpoints.size() << "checkpoints,"
             << data.hints.size() << "hints)";

    return !data.cityId.isEmpty();
}